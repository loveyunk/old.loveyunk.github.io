---
layout: post
title:  vue问题总结
date:   2018-05-14
---

#### vue组件什么时候销毁？
* 路由切换router-link组件会销毁

#### props改变子组件未重新渲染？
* vue子组件props赋值给data由data驱动视图，父组件改变props，子组件不会得绘。由props直接驱动会重绘。data只是赋了一个初值。
* props要么就直接用在子组件的视图中，父组件改变props则子组件就会重绘。要么赋值给data当作第一次初值来使用。父组件再改变props则不会引会重绘。可以使用watch观察。

#### props分类
* 父组件状态，来操纵子组件
* 父组件提供一次初值，子组件用data或computed接收，然后子组件内部消化，此时父组件改变，不会引发子组件的重新渲染，如果想重新渲染，可以在子组件使用watch。

#### vue表单双向绑定
* 之所以表单上才有双向绑定，因为只有表单才能在视图上触发改变。
* 双向指的是view与model
* `v-model='something'`的本质是 `:value='something'` 这是model->view,`@input='something=$event.target.value'`这是view->model

#### 生命周期

#### 理解nextTick

* 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。
* 重点是`获取更新后的DOM`
* Vue是异步执行dom更新的

#### 什么时候使用$nextTick
* 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。
* mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick.

```js
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>
```

```js
new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})
```


